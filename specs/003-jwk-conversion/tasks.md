# Tasks: JWK Conversion Support

**Input**: Design documents from `/specs/003-jwk-conversion/`
**Prerequisites**: plan.md (required), spec.md (required for user stories), research.md, data-model.md

**Tests**: The feature specification includes test scenarios and acceptance criteria that should be implemented as unit tests.

**Organization**: Tasks are grouped by user story to enable independent implementation and testing of each story.

## Format: `[ID] [Story] Description`

- **[Story]**: Which user story this task belongs to (e.g., US1, US2, US3)
- Include exact file paths in descriptions

## Path Conventions

- **Go project**: `japikey/`, `internal/`, `jwx/`, `tests/`, `example/` at repository root
- Paths follow the project structure defined in plan.md

---


## Phase 2: User Story 1 - JWX Verification Tool (Priority: P1) ðŸŽ¯ MVP

**Goal**: As a user, I can use the jwx tool which has two commands: parse - which takes a JSON string via stdin and prints via stdout the single public key as a base64 encoded string (or an error message), and generate, which takes a public key in stdin (as a base64 string) along with the key uuid as an argument and prints via stdout the jwks json.

**Independent Test**: Can be fully tested by running the tool with various inputs and validating the outputs. The parse command should accept valid JWK JSON and return the public key as base64, while the generate command should accept a base64 public key and UUID to generate a JWKS JSON.

### Implementation for User Story 1

- [x] T001 [US1] Create jwx tool project structure in jwx/tool/ with main.go, parse.go, generate.go (FR-051)
- [x] T002 [US1] Implement parse command to read JSON from stdin and output base64 public key in jwx/tool/parse.go (FR-052)
- [x] T003 [US1] Implement error handling for invalid JWK in parse command in jwx/tool/parse.go (FR-053)
- [x] T004 [US1] Implement generate command to read base64 public key from stdin and UUID from args in jwx/tool/generate.go (FR-054)
- [x] T005 [US1] Implement generate command to output JWKS JSON in jwx/tool/generate.go (FR-054)
- [x] T006 [US1] Create separate go module for tool using lestrrat-go/jwx/jwk in jwx/tool/go.mod (FR-057)
- [x] T007 [US1] Create jwx CLI tool with its own go.mod in jwx/tool/ (FR-038)
- [x] T008 [US1] Implement jwx CLI tool to generate example keys and JWKS in jwx/tool/generate.go (FR-038)
- [x] T009 [US1] Add makefile command to execute jwx CLI tool in Makefile (FR-039)
- [x] T010 [US1] Update Makefile to build jwx tool before running tests (FR-055)
- [x] T011 [US1] Ensure the jwx tool works correctly

**Checkpoint**: At this point, User Story 1 should be fully functional and testable independently

---

**Note**: Tests are not required for the jwx verification tool itself. The tool is intended as a verification utility to validate the format of JWKS generated by the main library. Manual validation of the tool's functionality is sufficient.

---

## Phase 3: Foundational
**Purpose**: Core infrastructure that the remaining user stories depend on

- [ ] T012 Setup library structure with clear interfaces per Library-First Architecture principle in internal/jwks/
- [ ] T013 Implement structured error types (InvalidJWK, UnexpectedConversionError, KeyNotFoundError) in japikey/errors.go
- [ ] T014 Setup internal/jwks package with lowercase field names to enforce encapsulation
- [ ] T015 Create base JWK and JWKS structs with validation per data-model.md in internal/jwks/jwks.go
- [ ] T016 Configure custom JSON marshaling/unmarshaling for JWKS format compliance in internal/jwks/jwks.go
- [ ] T017 Implement Base64urlUInt encoding/decoding functions per RFC 7518 in internal/jwks/jwks.go

**Checkpoint**: Foundation ready - user story implementation can now begin

---

## Phase 4: User Story 2 - Generate JWKS from Public Key (Priority: P2)

**Goal**: As a user, I can generate a JWKS containing exactly one RS256 key from a public key NewJWK(rsa.publicKey, kid), and I can serialize and deserialize that value to and from JSON. Given an invalid kid, this fails.

**Independent Test**: Can be fully tested by providing a valid RSA public key and key ID to the NewJWK function, verifying the resulting JWKS contains exactly one RS256 key, and confirming that serialization/deserialization to and from JSON works properly. Also verify that invalid key IDs result in appropriate error responses.

### Tests for User Story 2

> **NOTE: Write these tests FIRST, ensure they FAIL before implementation**

- [ ] T018 [US2] Unit test for NewJWK with valid RSA public key and UUID in internal/jwks/jwks_test.go
- [ ] T019 [US2] Unit test for NewJWK with invalid key ID (not UUID) in internal/jwks/jwks_test.go
- [ ] T020 [US2] Unit test for NewJWK with null RSA public key in internal/jwks/jwks_test.go
- [ ] T021 [US2] Unit test for JWKS serialization to JSON in internal/jwks/jwks_test.go
- [ ] T022 [US2] Unit test for JWKS deserialization from JSON in internal/jwks/jwks_test.go
- [ ] T023 [US2] Unit test for invalid JSON deserialization in internal/jwks/jwks_test.go
- [ ] T024 [US2] Unit test for invalid RSA parameters in JSON in internal/jwks/jwks_test.go
- [ ] T025 [US2] Unit test to validate generated JWKS format using jwx tool in internal/jwks/jwks_test.go

### Implementation for User Story 2

- [ ] T026 [US2] Implement NewJWK function in internal/jwks/jwks.go that accepts RSA public key and key ID (FR-001)
- [ ] T027 [US2] Add validation for key ID (kid) to be valid UUID format in internal/jwks/jwks.go (FR-002)
- [ ] T028 [US2] Add validation for RSA public key to not be null in internal/jwks/jwks.go (FR-003)
- [ ] T029 [US2] Implement custom MarshalJSON method for JWKS in internal/jwks/jwks.go (FR-007)
- [ ] T030 [US2] Implement custom UnmarshalJSON method for JWKS in internal/jwks/jwks.go (FR-007)
- [ ] T031 [US2] Ensure generated JWKS contains required parameters: kty, kid, n, e in internal/jwks/jwks.go (FR-010-012)
- [ ] T032 [US2] Validate that kty parameter is "RSA" in internal/jwks/jwks.go (FR-013)
- [ ] T033 [US2] Validate that n and e parameters are present and properly formatted in internal/jwks/jwks.go (FR-014)
- [ ] T034 [US2] Ensure JWKS contains exactly one key in internal/jwks/jwks.go (FR-015)
- [ ] T035 [US2] Validate member names are unique in internal/jwks/jwks.go (FR-016)
- [ ] T036 [US2] Ensure only supported parameters are accepted in internal/jwks/jwks.go (FR-017-018)
- [ ] T037 [US2] Implement proper Base64urlUInt encoding for n and e parameters in internal/jwks/jwks.go (FR-025-031)

**Checkpoint**: At this point, User Story 2 should be fully functional and testable independently

---

## Phase 5: User Story 3 - Extract Public Key and Key ID from JWKS (Priority: P3)

**Goal**: As a user, I can take an existing JWKS, and return the public key for a given kid. Given a JWKS, I can see which kid is present for it. Otherwise, I get the appropriate error message if the kid is missing or the JWKS is malformed for whichever reason.

**Independent Test**: Can be fully tested by creating a valid JWKS, extracting the public key for a known key ID, and verifying it matches the original. Also test extracting the key ID from the JWKS and verifying error handling for malformed JWKS or missing key IDs.

### Tests for User Story 3

- [ ] T038 [US3] Unit test for extracting public key for known key ID in internal/jwks/jwks_test.go
- [ ] T039 [US3] Unit test for extracting key ID from JWKS in internal/jwks/jwks_test.go
- [ ] T040 [US3] Unit test for missing key ID error in internal/jwks/jwks_test.go
- [ ] T041 [US3] Unit test for non-matching key ID error in internal/jwks/jwks_test.go
- [ ] T042 [US3] Unit test for malformed JWKS error in internal/jwks/jwks_test.go
- [ ] T043 [US3] Unit test to validate JWKS format using jwx tool in internal/jwks/jwks_test.go

### Implementation for User Story 3

- [ ] T044 [US3] Implement GetPublicKey method to return RSA public key for given key ID in internal/jwks/jwks.go (FR-004)
- [ ] T045 [US3] Implement GetKeyID method to return the key ID present in JWKS in internal/jwks/jwks.go (FR-005)
- [ ] T046 [US3] Add validation that key ID in JWKS is valid UUID when extracting it in internal/jwks/jwks.go (FR-008)
- [ ] T047 [US3] Add validation that public key in JWKS is valid RSA public key when extracting it in internal/jwks/jwks.go (FR-009)
- [ ] T048 [US3] Implement KeyNotFoundError for when kid is not present in JWKS in japikey/errors.go (FR-049)
- [ ] T049 [US3] Validate that key ID in JWKS matches requested key ID in internal/jwks/jwks.go (FR-032)

**Checkpoint**: At this point, User Stories 1, 2 AND 3 should all work independently

---

## Phase 6: User Story 4 - Get JWKS from JAPIKey (Priority: P4)

**Goal**: As a user with a valid JAPIKey, there is a helper method to get the JWKS from it.

**Independent Test**: Can be fully tested by creating a valid JAPIKey, calling the helper method to get the JWKS, and verifying the resulting JWKS contains the correct key ID and public key information.

### Tests for User Story 4

- [ ] T050 [US4] Unit test for JAPIKey to JWKS conversion with valid inputs in japikey/jwks_test.go
- [ ] T051 [US4] Unit test for JAPIKey to JWKS conversion with invalid key ID in japikey/jwks_test.go
- [ ] T052 [US4] Unit test for JAPIKey to JWKS conversion with null public key in japikey/jwks_test.go
- [ ] T053 [US4] Unit test to validate generated JWKS format using jwx tool in japikey/jwks_test.go

### Implementation for User Story 4

- [ ] T054 [US4] Implement ToJWKS helper method on JAPIKey struct in japikey/japikey.go (FR-035)
- [ ] T055 [US4] Add validation that JAPIKey contains valid UUID key ID before conversion in japikey/japikey.go (FR-036)
- [ ] T056 [US4] Add validation that JAPIKey contains valid RSA public key before conversion in japikey/japikey.go (FR-037)

**Checkpoint**: All user stories should now be independently functional

---

## Phase 7: Polish & Cross-Cutting Concerns

**Purpose**: Improvements that affect multiple user stories

- [ ] T057 Documentation updates in docs/ ensuring Developer Ease of Use with comprehensive examples
- [ ] T058 Code cleanup and refactoring to maintain library-first architecture
- [ ] T059 Performance optimization across all stories
- [ ] T060 Additional security-focused unit tests in tests/unit/
- [ ] T061 Security hardening per Security-First Testing principle
- [ ] T062 Run quickstart.md validation to ensure Developer Ease of Use
- [ ] T063 Verify all features meet Library-First Architecture requirements
- [ ] T064 Create example usage file in example/jwks_example.go
- [ ] T065 Generate test JWKS file for verification in example/jwks.json

---

## Dependencies & Execution Order

### Phase Dependencies

- **Setup (Phase 1)**: No dependencies - can start immediately
- **User Story 1 (Phase 2)**: Can start immediately - No dependencies on other stories
- **Foundational (Phase 3)**: Depends on Setup completion - BLOCKS User Stories 2, 3, and 4
- **User Stories (Phase 4+)**: All depend on Foundational phase completion
  - Sequentially in priority order (P2 â†’ P3 â†’ P4)
- **Polish (Final Phase)**: Depends on all desired user stories being complete

### User Story Dependencies

- **User Story 1 (P1)**: Can start immediately - No dependencies on other stories
- **User Story 2 (P2)**: Can start after Foundational (Phase 3) - May integrate with US1 but should be independently testable
- **User Story 3 (P3)**: Can start after Foundational (Phase 3) - May integrate with US1/US2 but should be independently testable
- **User Story 4 (P4)**: Can start after Foundational (Phase 3) - May integrate with US1/US2/US3 but should be independently testable

### Within Each User Story

- Tests MUST be written and FAIL before implementation
- Models before services
- Services before endpoints
- Core implementation before integration
- Story complete before moving to next priority

---

## Implementation Strategy

### MVP First (User Story 1 Only)

1. Complete Phase 1: Setup
2. Complete Phase 2: User Story 1 (JWX Verification Tool) - Can begin immediately
3. Complete Phase 3: Foundational (CRITICAL - blocks User Stories 2, 3, and 4)
4. **STOP and VALIDATE**: Test User Story 1 independently
5. Deploy/demo if ready

### Incremental Delivery

1. Complete Setup + User Story 1 â†’ MVP available
2. Complete Foundational â†’ Foundation ready for remaining stories
3. Add User Story 2 â†’ Test independently â†’ Deploy/Demo
4. Add User Story 3 â†’ Test independently â†’ Deploy/Demo
5. Add User Story 4 â†’ Test independently â†’ Deploy/Demo
6. Each story adds value without breaking previous stories

---

## Notes

- [Story] label maps task to specific user story for traceability
- Each user story should be independently completable and testable
- Verify tests fail before implementing
- Commit after each task or logical group
- Stop at any checkpoint to validate story independently
- Avoid: vague tasks, same file conflicts, cross-story dependencies that break independence

---

## Additional Tasks

- [x] T066 Add gitignore entry to ignore compiled binaries per FR-059
